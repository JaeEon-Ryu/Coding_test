# 연산 : 더하기 or 빼기 (2가지)
#
#
# ex : 타겟 넘버 3
# numbers = [1,1,1,1,1]
#
# 배열의 0번째 원소부터 하나씩 더해감
# 타겟넘버가 될 때 까지 ?
# 정해진 타겟넘버를 넘는다 -> 돌아가서 뺸다
#
# -------------------------------------------------
# 순환구조. 재귀함수를 써야 할 듯
# 깊이우선탐색 -> DFS
#
# 타겟넘버 4
# number = [1,2,3]
# 라면 가능성은
# -1,2,3       4
# -1,2,-3     -2
# -1,-2,3      0
# -1,-2,-3    -6
# 1,2,3        6
# 1,2,-3       0
# 1,-2,3       2
# 1,-2,-3     -4
#
# => 답은 1
# 리스트의 원소가 3개일 경우 2의 3승으로 경우의 수 8
# 원소가 2개 -> 2의 2승 -> 4
# 원소가 4개 -> 2의 4승 -> 16
#
# 1 1 1 1
# 2 2 -2 -2
# 3 -3 3 -3
# -1 -1 -1 -1
# 2 2 -2 -2
# 3 -3 3 -3
#
# 코드화 ->
# [1,2,3]
# [1,2,3]
#
# 배열구조 - 트리형식으로 만들어야 한다
# => 최초의 반복문은 주어진 numbers로 쓴다.
# numbers 반복문안에 이중 루프를 쓰는데
# 그 이중루프는 numbers가 반복될 때 마다
# 트리구조로 늘어나야 한다.
# --->      1                -1
#       2       -2       2        -2
#    3   -3  3   -3  3   -3   3     -3


def solution(numbers, target):
    answer = 0
    tree = [0]
    for n in numbers:
        temp_list = []
        for t in tree:
            temp_list.append(t+n)
            temp_list.append(t-n)
        tree = temp_list
    answer = tree.count(target)
    return answer






